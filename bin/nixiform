#!/usr/bin/env bash
set -eo pipefail

# Exit codes:
#   1  no instance with name
#   2  no config with name
#   3  no configurator for provider
#   4  config build failed
#   5  not a valid config closure
#   6  no input file found
#   7  no deploy file (nixiform.nix) found
#   8  config push failed
#   9  couldn't reach instance
#  10  no instance with name
#  11  couldn't copy closure to node
#  12  refuse to infect when dry push
#  13  invalid option
#  14  couldn't copy derivation closure to node
#  100 instance needs reboot to complete

BIN_DIR=$(cd "${BASH_SOURCE[0]%/*}"; pwd)
LIB_DIR="${BIN_DIR%/*}/lib"
INPUT_CACHE_NIX="./.input-cache.json"
INPUT_CACHE="./.nixiform/.input-cache.json"
SSH_OPTS=(-o "LogLevel=ERROR" -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" "${NF_SSH_OPTS[@]}")

NF_CONFIGURATOR_PATH="${NF_CONFIGURATOR_PATH-./.nixiform/configurators:$LIB_DIR/configurators}"

version() { tr -d '\n' < "$LIB_DIR"/version; }

help() {
  cat >&2 <<EOF
Usage: nixiform COMMAND [ARGS]

Commands:

  init NAMES..            Create input from Terraform state
  initFromJSON NAMES..    Create input from ./nixiform-input.json
  input JSON_PATH         Print input data
  check NAMES..           Check reachability of nodes
  build NAMES..           Build configurations
  push  OPTIONS NAMES..   Push configurations to nodes
    -l|--local            Realize derivation locally
    -d|--dry              Upload closure but do not switch to configuration
    -r|--auto-reboot      Reboot instance if needed (default is to fail instead)
  diff  NAMES..           Show diff of local and remote configuration
  help                    This message

Environment variables:

  NF_CONFIGURATOR_PATH    Where to look for provider configurators
                          Default: ".nixiform/configurators"
  NF_NIX_BUILD_OPTS       Additional arguments to pass to \`nix-build\`
                          Example: "--show-trace"
  NF_SSH_OPTS             Additional aguments to pass to \`ssh\`
                          Example: "-i ~/.ssh/id_rsa"

Version: $(version)
EOF
}

_usage() { printf >&2 "Error: %s\n\n" "$*"; help; exit 10; }

_ilog() { sed "s|^|$1> |" >&2; }

_remote() {
  # shellcheck disable=SC2086 disable=SC2029
  ssh "${SSH_OPTS[@]}" root@"$1" "${@:2}"
}

_configuratorPath() {
  PATH="$NF_CONFIGURATOR_PATH" command -v "${1:-default}"
}

_infect() {
  _remote "$1" bash /dev/stdin "${@:2}" < "$LIB_DIR"/infect
}

_configure() {
  _remote "$2" bash < "$(_configuratorPath "$1")"
}

_instance() {
  # shellcheck disable=SC2119
  input | jq -r ".nodes.\"$1\" | .$2 // \"\""
}

_configs() {
  [ -f "./nixiform.nix" ] \
    || { echo >&2 "Error: No deploy file (nixiform.nix) found"; return 7; }
  _inputHook && nix-instantiate --eval-only --json -E "
    with import <nixpkgs> {};with builtins;
    attrNames (import ./nixiform.nix (lib.importJSON $INPUT_CACHE))
  " | jq -r '.[]'
}

_secrets() {
  local name="$1"
  local confPath
  local provider

  _checkInstance "$name"
  provider=$(_instance "$name" provider)
  confPath="./.nixiform/configuration-$provider-$name.nix";

  nix-instantiate --eval-only --strict --json -E "
    with import <nixpkgs/nixos> { configuration = $confPath;}; with builtins;
    if (config?nixiform && config.nixiform?filesIn)
    then map (k: let i = config.nixiform.filesIn.\"\${k}\"; in
        [ i.path config.nixiform.filesOut.\"\${k}\" ]
      ) (attrNames config.nixiform.filesIn)
    else []
  "
}

_pushSecrets() {
  local name="$1"
  local ip
  local file

  ip=$(_instance "$name" ip)
  file=$(_secrets "$name" | jq -c '.[]') || return $?
  if [[ -n $file ]]; then
    _remote "$ip" "mkdir -p /run/nf-keys"
  fi
  while read -r line && [ -n "$line" ]; do
    mapfile -t l < <(jq -r '.[]' <<<"$line")
    find "${l[0]}" | sed >&2 's/^/Uploading /'
    scp >&2 -rB "${SSH_OPTS[@]}" "${l[0]}" root@"$ip":"${l[1]}"
  done <<<"$file"
}

_checkInstance() {
  local name

  name=$(_instance "$1") || return $?
  [ -n "$name" ] || { echo >&2 "Error: No instance with name: $1"; return 1; }
}

_checkInstances() {
  local names
  local names_

  if [ -n "$*" ]
    then names=("$@")
    else names_=$(_configs) || return $?; mapfile -t names < <(echo "$names_")
  fi
  for name in "${names[@]}"; do
    _checkInstance "${name}" || return $?
    echo "${name}"
  done
}

_checkConfigurator() {
  [ -f "$(_configuratorPath "$1")" ] || {
    echo >&2 "Error: No configurator found for provider: $1"; return 3
  }
}

_checkUp() {
  local ip

  ip=$(_instance "$1" ip)
  echo >&2 "Checking SSH connection..."
  for i in $(seq 3); do
    _remote "$ip" true && return 0 || echo >&2 "Info: SSH connection failed, try $i/3"
    sleep 5
  done
  echo >&2 "Error: Couldn't connect over SSH"
  return 1
}

_initInstance() {
  local name
  local ip
  local provider
  local physicalNix
  local confPath

  name="$1"
  _checkInstance "$name"

  provider=$(_instance "$name" provider)
  _checkConfigurator "$provider" || return $?

  ip=$(_instance "$name" ip)

  echo >&2 "Initializing config..."

  # Aggrigate instance config with custom configs
  mkdir -p .nixiform

  # Get instance specific config
  confPath="./.nixiform/configuration-$provider-$name.nix";
  physicalNix=$(_configure "$provider" "$ip") || return $?

  _inputHook && cat > "$confPath" <<EOF
{ lib, ... }: with builtins; let
  input = lib.importJSON $INPUT_CACHE_NIX;
  node = input.nodes."$name";
  hashDir = dir:
    mapAttrs (k: v: let p = "\${dir}/\${k}"; in
      if v == "regular" then hashFile "sha1" p
      else if v == "directory" then hashDir p
      else "")
    (readDir dir);
  hash = path: let p = toString path; in
    if (readDir (dirOf p))."\${baseNameOf p}" == "directory"
    then hashString "sha1" (toJSON (hashDir p))
    else hashFile "sha1" p;
in {
  _module.args = { inherit input node; };
  require = [
    # Secrets module
    ({ lib, config, ... }: with lib; {
      options.nixiform.filesIn = mkOption {
        description = "Attrset of paths to local files, name -> local path.";
        type = with types; attrsOf (submodule { options = {
          path = mkOption { type = path; };
          chmod = mkOption { type = strMatching "[0-7]+"; default = "0600"; };
          user = mkOption { type = enum (attrNames config.users.users); default = "root"; };
          group = mkOption { type = enum (attrNames config.users.groups); default = "root"; };
        };});
        default = {};
      };
      options.nixiform.filesOut = mkOption {
        description = "Attrset of paths to remote files, name -> server path.";
        type = with types; attrsOf str;
        default = {};
      };
      config.nixiform.filesOut = mapAttrs (k: v: "/run/nf-keys/"+(hash v.path)) config.nixiform.filesIn;
      config.system.activationScripts.nf-keys-permissons = ''
        mkdir -p /run/nf-keys
        chmod 755 /run/nf-keys
        find /run/nf-keys -mindepth 1 -maxdepth 1 \\
          \${concatMapStrings (p: " ! -path '\${p}' ") (attrValues config.nixiform.filesOut)} \\
          -exec rm -rf {} \;
      ''
      + concatMapStrings (k: let
        i = config.nixiform.filesIn."\${k}";
        o = config.nixiform.filesOut."\${k}";
      in ''
        chmod -R "\${i.chmod}" "\${o}"
        find "\${o}" -type d -exec chmod ug+x {} \;
        chown -R "\${i.user}:\${i.group}" "\${o}"
      '') (attrNames config.nixiform.filesIn);
    })

    # Hardware config gernerated by configurator: $provider
    ($physicalNix)

    # Node specific config
    (import ../nixiform.nix input)."$name"
  ];
  networking.hostName = "$name";
  services.openssh.enable = true;
  users.users.root.openssh.authorizedKeys.keys = [node.ssh_key];
  #system.activationScripts.nixos-cleanup = "rm -rf /old-root /boot.bak || true";
}
EOF

  echo "$name" "$confPath"
}

_buildInstance() {
  local ecode=0
  local name="$1"
  local confPath
  local provider

  _checkInstance "$name"
  provider=$(_instance "$name" provider)
  confPath="./.nixiform/configuration-$provider-$name.nix";

  echo >&2 "Building config..."

  # Build config derivation
  # shellcheck disable=SC2086
  nix-instantiate $NF_NIX_BUILD_OPTS '<nixpkgs/nixos>' -A system --arg configuration "$confPath"
  #nix-build $NF_NIX_BUILD_OPTS --no-out-link '<nixpkgs/nixos>' -A system \
  #  --arg configuration "$confPath"
}

_pushInstance() {
  local op; op="switch"
  local name
  local ip
  local provider
  local path

  while [[ -n "$1" ]]; do case "$1" in
    -l|--local) localRealize=1;;
    -d|--dry) op="dry-activate";;
    -r|--auto-reboot) forceReboot=1;;
    -*) echo >&2 "Not a recognized push option '$1'"; return 13;;
    *)
      if [ -z "$name" ]; then name="$1"
      elif [ -z "$path" ]; then path="$1"
      fi
      ;;
  esac; shift; done

  _checkInstance "$name"
  ip=$(_instance "$name" ip)

  [[ -e "$path" ]] || { echo >&2 "Error: Not a valid config closure: $path"; return 5; }

  echo >&2 "Pushing config ($op)..."

  # XXX: move groupadd to lib/infect
  # Install Nix if not already installed
  _infect "$ip" hasNix || {
    [[ "$op" = "switch" ]] || {
      echo >&2 "Refusing to infect instance with NixOS because option --dry was given"
      exit 12
    }
    cat <(cat <<EOF
mkdir -m 0755 /nix
groupadd nixbld -g 30000 || true
for i in {1..10}; do
  useradd -c "Nix build user $i" \
    -d /var/empty -g nixbld -G nixbld \
    -M -N -r -s "$(command -v nologin)" nixbld$i \
  || true
done
EOF
    ) "$LIB_DIR"/install-nix-2.3 | _remote "$ip" sh
  }

  # Push config closure to instance
  if [[ -n $localRealize ]]; then
    NIX_SSHOPTS="${SSH_OPTS[*]} PATH=/root/.nix-profile/bin:\$PATH" \
      nix-copy-closure -s --to root@"$ip" "$path" \
      || { echo >&2 "Error: Failed to copy derivation closure to node: $path"; return 14; }
    path=$(_remote "$ip" nix-store -r "$path") \
      || { echo >&2 "Error: Failed to realize derivation on node: $path"; return 14; }
  else
    path=$(nix-store -r "$path")
    NIX_SSHOPTS="${SSH_OPTS[*]} PATH=/root/.nix-profile/bin:\$PATH" \
      nix-copy-closure -s --to root@"$ip" "$path" \
      || { echo >&2 "Error: Failed to copy closure to node: $path"; return 11; }
  fi


  # Install config and infect instance with NixOS if not already
  _infect "$ip" switch "$op" "$path" || {
    case "$?" in
      200)
        echo >&2 "Refusing to infect instance with NixOS because option --dry was given"
        exit 12
        ;;
      100)
        echo >&2 "Instance needs to reboot to finish configuration"
        if [[ -n "$forceReboot" ]]; then
          echo >&2 "Rebooting..."
          _remote "$ip" reboot || true
        else
          echo >&2 "Refusing to reboot, use option --auto-reboot or reboot instance manually"
          exit 100
        fi
        ;;
      4)
        echo >&2 "Warning: Couldn't start all services"
        ;;
      *)
        return 8
        ;;
    esac
  }
}

_init() {
  local instances

  instances=$(_checkInstances "$@") || return $?
  check "$@" || return $?
  while read -r name; do
    _initInstance "$name" \
      2> >(_ilog "$name")
  done <<<"$instances"
}

_inputHook() {
  [[ -f "$INPUT_CACHE" ]] || {
    [[ -x ./.nixiform/input-hook ]] \
      || { echo >&2 "Error: Couldn't find an executable input hook, try running: nixiform init"; return 6; }
    ./.nixiform/input-hook > "$INPUT_CACHE"
  }
}

# CLI commands

init() {
  mkdir -p .nixiform
  cp "$LIB_DIR"/input-hooks/default .nixiform/input-hook
  chmod u+wx .nixiform/input-hook
  _init "$@"
}

# TODO: clean up and move hook script to lib/input-hooks/
initFromJSON() {
  [[ -f ./nixiform-input.json ]] \
    || { echo >&2 "Error: Couldn't find input JSON at $PWD/nixiform-input.json"; return 6; }
  mkdir -p .nixiform
  cat > .nixiform/input-hook <<EOF
#!/usr/bin/env bash
cat ./nixiform-input.json
EOF
  chmod +x .nixiform/input-hook
  _init "$@"
}

# shellcheck disable=SC2120
input() {
  { _inputHook && jq -rM ".$1 // \"\"" "$INPUT_CACHE"; } \
    || { echo >&2 "Error: Input transform failed"; return 6; }
}

check() {
  local instances
  local ecode; ecode=0

  instances=$(_checkInstances "$@") || return $?
  for name in $instances; do
    _checkUp "$name" \
      2> >(_ilog "$name") \
      || { ecode=9; continue; }
  done
  [ "$ecode" == 0 ] || echo >&2 "Error: Couldn't reach all instance"
  return $ecode
}

build() {
  local path
  local instances

  instances=$(_checkInstances "$@") || return $?
  while read -r name; do
    { path=$(_buildInstance "$name") || {
        echo >&2 "Error: Failed to build config"; return 4
      }
    } 2> >(_ilog "$name")
    echo "$name" "$path"
  done <<<"$instances"
}

push() {
  local name
  local path
  local buildOutput
  local names
  local flags

  while [[ -n "$1" ]]; do case "$1" in
    -*) flags+=("$1");;
    *) names+=("$1");;
  esac; shift; done

  buildOutput=$(build "${names[@]}") || return $?
  check "${names[@]}" || return $?
  while read -r name path; do
    _pushSecrets "$name" \
      2> >(_ilog "$name")
    _pushInstance "$name" "$path" "${flags[@]}" \
      2> >(_ilog "$name") || return $?
  done <<<"$buildOutput"
  check "${names[@]}" || return $?
}

diff() {
  local name
  local path
  local buildOutput
  local names
  local ip

  while [[ -n "$1" ]]; do case "$1" in
    -*) echo >&2 "Not a recognized diff option: $1"; return 13;;
    *) names+=("$1");;
  esac; shift; done

  buildOutput=$(build "${names[@]}") || return $?
  while read -r name path; do
    ip=$(_instance "$name" ip)
    nix-diff \
      "$(_remote "$ip" nix-store -qd /nix/var/nix/profiles/system)" \
      "$(nix-store -qd "$path")" \
      2> >(_ilog "$name") || return $?
  done <<<"$buildOutput"
}

secret() {
  local instances
  local name

  instances=$(_checkInstances "$@") || return $?
  while read -r name; do
    _pushSecrets "$name" \
      2> >(_ilog "$name")
  done <<<"$instances"
}

trap 'trap - EXIT; rm -f "$INPUT_CACHE"' EXIT
trap 'trap - TERM; kill $$' TERM

cmd=${1:-help}
declare -F | cut -d' ' -f3 | grep -q "^${cmd#_}$" \
  || _usage "No command: $cmd"

"${cmd#_}" "${@:2}" && printf "\nDone!\n" >&2
