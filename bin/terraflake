#!/usr/bin/env bash
set -eo pipefail
shopt -s inherit_errexit failglob

# Exit codes:
#   1  no instance with name
#   2  no config with name
#   3  no configurator for provider
#   4  config build failed
#   5  not a valid config closure
#   6  no input file found
#   7  no deploy file (terraflake.nix) found
#   8  config push failed
#   9  couldn't reach instance
#  10  wrong arguments to CLI
#  11  couldn't copy closure to node
#  12  refuse to infect when dry push
#  13  invalid option
#  14  couldn't copy derivation closure to node
#  15  couldn't get system of remote node
#  100 instance needs reboot to complete

BIN_DIR=$(cd "${BASH_SOURCE[0]%/*}"; pwd)
export BIN_DIR
LIB_DIR="${BIN_DIR%/*}/lib"
export LIB_DIR
SSH_OPTS="-o
LogLevel=ERROR
-o
UserKnownHostsFile=/dev/null
-o
StrictHostKeyChecking=no"
[[ -z $NF_SSH_OPTS ]] || SSH_OPTS+="
$NF_SSH_OPTS"
export SSH_OPTS

NF_DIR="terraflake"
export NF_DIR
NF_FLAKE="${NF_FLAKE:-.}"
export NF_FLAKE
NF_CONFIGURATOR_PATH="${NF_CONFIGURATOR_PATH-./$NF_DIR/configurators:$LIB_DIR/configurators}"
export NF_CONFIGURATOR_PATH
NF_PAR="${NF_PAR-1}"
export NF_PAR

SSH_EXEC=$(which ssh)
export SSH_EXEC

version() { tr -d '\n' < "$LIB_DIR"/version; }
export -f version

help() {
  cat >&2 <<EOF
Usage: terraflake COMMAND [ARGS]

Commands:

  init   NAMES..          Create input from Terraform state
  input  JSON_PATH        Print input data (e.g. "nodes[].ip")
  check  NAMES..          Check reachability of nodes
  build  NAMES..          Build configurations
  push   OPTIONS NAMES..  Push configurations to nodes
    -l|--local            Realize derivation locally
    -b|--bundle           Bundle derivations
    -d|--dry              Upload closure but do not switch to configuration
    -r|--auto-reboot      Reboot instance if needed (default is to fail instead)
  secret NAMES..          Copy secrets to remote nodes
    -d|--dry              Check but don't copy
    -f|--force            Force copy
  diff   NAMES..          Show diff of local and remote configuration
  output NAME NIX_EXPR    Print NixOS config using a Nix expression, e.g. \`nix.settings\`
  ssh NAME                SSH to node (sugar for \`ssh root@\$(terraflake input ".nodes.<NAME>.ip")\`)
  nodes                   List node names (sugar for \`terraflake input ".nodes | keys | .[]"\`)
  help                    This message

Environment variables:

  NF_FLAKE                Flake reference to evaluate (e.g. github:icetan/terraflake-example)
                            Default: .
  NF_CONFIGURATOR_PATH    Where to look for provider configurators
                            Default: "$NF_DIR/configurators"
  NF_NIX_BUILD_OPTS       Additional arguments to pass to \`nix-build\`
                            Example: "--show-trace"
  NF_SSH_OPTS             Additional aguments to pass to \`ssh\`
                            Example: "-i ~/.ssh/id_rsa"
  NF_PAR                  Set how many parallel process to launch
                            Default: 1

Version: $(version)
EOF
}

_usage() { printf >&2 "Error: %s\n\n" "$*"; help; exit 10; }

_ilog() { sed "s|^|$1> |" >&2; }
export -f _ilog

_par() {
  # shellcheck disable=SC2030
  xargs -L1 -P"$NF_PAR" bash -c "set -eo pipefail;shopt -s inherit_errexit failglob; $([[ -z $NF_DEBUG ]] || echo set -x\;) $1" _ "${@:2}"
}
export -f _par

_remote() {
  mapfile -t opts <<<"$SSH_OPTS"
  # shellcheck disable=SC2086 disable=SC2029
  $SSH_EXEC "${opts[@]}" root@"$1" "${@:2}"
}
export -f _remote

_configuratorPath() {
  PATH="$NF_CONFIGURATOR_PATH" command -v "${1:-default}"
}
export -f _configuratorPath

_infect() {
  _remote "$1" bash /dev/stdin "${@:2}" < "$LIB_DIR"/infect
}
export -f _infect

_configure() {
  local path
  path=$(_configuratorPath "$1")
  _remote "$2" bash < "$path"
}
export -f _configure

_instance() {
  # shellcheck disable=SC2119
  input | jq -r ".nodes.\"$1\" | .$2 // \"\""
}
export -f _instance

_configs() {
  input | jq -r '.nodes | keys | .[]'
}
export -f _configs

_confPath() {
  local name="$1"
  local provider
  local path

  _checkInstance "$name"
  provider=$(_instance "$name" provider)
  path="./$NF_DIR/module-$name.nix"

  [[ -f $path ]] \
    || { echo >&2 "INFO: Not yet initialized"; _initInstance "$name" >/dev/null; }
  printf %s "$path"
}
export -f _confPath

_system() {
  nix eval --impure --raw --expr 'builtins.currentSystem'
}
export -f _system

_remoteSystem() {
  local ip="$1"
  local system
  # shellcheck disable=SC2016
  system=$(_remote "$ip" sh -c 'true; echo "$(uname -m)-$(uname)"')
  echo "${system,,}"
}
export -f _remoteSystem

_output() {
  local name="$1"
  local expr="${*:2}"
  nix eval "$NF_FLAKE#nixosConfigurations.$name.config" \
    --json --apply "$expr"
}
export -f _output

_caches() {
  local name="$1"
  # shellcheck disable=SC2016
  _output "$name" '{ nix, ... }: with builtins; map (concatStringsSep " ") [
    (nix.settings.substituters or nix.binaryCaches or [])
    (nix.settings.trusted-public-keys or nix.binaryCachePublicKeys or [])
  ]'
}
export -f _caches

_secrets() {
  local name="$1"
  # shellcheck disable=SC2016
  _output "$name" '{ terraflake, ... }: with builtins;
    if terraflake?filesIn
    then map (k: let i = terraflake.filesIn.${k}; in
        [ i.path terraflake.filesOut.${k} i.chmod i.user i.group ]
      ) (attrNames terraflake.filesIn)
    else []
  '
}
export -f _secrets

_pushSecrets() {
  local op
  local name
  local dry
  local force
  local ip
  local file
  local dir
  local tmp
  local rsec
  local own
  local cmd

  while [[ -n "$1" ]]; do case "$1" in
    -d|--dry) dry=1;;
    -f|--force) force=1;;
    -*) true;;
    *)
      if [[ -z "$name" ]]; then name="$1"
      # else { echo >&2 "Too many arguments given to build command"; return 13; }
      fi
      ;;
  esac; shift; done

  ip=$(_instance "$name" ip)
  file=$(_secrets "$name" | jq -c '.[]')
  dir=$(_output "$name" '{ terraflake, ... }: terraflake.filesDir' | jq -r .)
  tmp=$(mktemp -d tmpsecret.XXXXX)
  rsec=$(_remote "$ip" sh -c "true
    mkdir -p \"$dir\"
    chmod 755 \"$dir\"
    find \"$dir\" -mindepth 1 -maxdepth 1
  " </dev/null)

  while read -r line && [ -n "$line" ]; do
    mapfile -t l < <(jq -r '.[]' <<<"$line")
    if [[ -z $force ]] && grep -q "^${l[1]}\$" <<<"$rsec"; then
      rsec=$(sed "/$(basename "${l[1]}")\$/d" <<<"$rsec")
    else
      cp -r "${l[0]}" "$tmp/$(basename "${l[1]}")"
      op=1
    fi
    own+="
      chmod -R ${l[2]} ${l[1]}
      find ${l[1]} -type d -exec chmod ug+x {} \\;
      chown -R ${l[3]}:${l[4]} ${l[1]} 2>/dev/null || true
    "
  done <<<"$file"

  if [[ -n $rsec ]]; then
    op=1
    if [[ -n $dry ]]; then
      cmd+="
        echo 'would remove: $rsec'
      "
    else
      cmd+="
        rm -rfv $(tr '\n' ' ' <<<"$rsec")
      "
    fi
  fi

  if [[ -n $own ]]; then
    if [[ -n $dry ]]; then
      cmd+="
        tar tzv | sed 's/^/would extract: /'
      "
    else
      cmd+="
        tar xz -C \"$dir\"
        $own
      "
    fi
  fi

  if [[ -n $cmd ]]; then
    { tar czv -C "$tmp" -T <(cd "$tmp"; ls -1A) --mtime='1970-01-01 01:00:00' \
      | _remote "$ip" sh -c "true;$cmd"
    } 2>&1 | sed 's/^/Secret /' >&2
  fi
  if [[ -z $op ]]; then
    echo >&2 "Secrets already in sync, doing nothing"
  fi
  rm -rf "$tmp"
}
export -f _pushSecrets

_checkInstance() {
  local name

  name=$(_instance "$1")
  [[ -n $name ]] || { echo >&2 "Error: No instance with name: $1"; return 1; }
}
export -f _checkInstance

_checkInstances() {
  local names

  if [ -n "$*" ]
    then names=("$@")
    else mapfile -t names < <(_configs)
  fi
  for name in "${names[@]}"; do
    _checkInstance "${name}"
    echo "${name}"
  done
}
export -f _checkInstances

_checkConfigurator() {
  local path
  path=$(_configuratorPath "$1")
  [[ -f "$path" ]] || {
    echo >&2 "Error: No configurator found for provider: $1"; return 3
  }
}
export -f _checkConfigurator

_checkUp() {
  local ip

  ip=$(_instance "$1" ip)
  echo >&2 "Checking SSH connection..."
  for i in $(seq 3); do
    _remote "$ip" true </dev/null \
      && return 0 || echo >&2 "Info: SSH connection failed, try $i/3"
    sleep 5
  done
  echo >&2 "Error: Couldn't connect over SSH"
  return 1
}
export -f _checkUp

_initInstance() {
  local name; name="$1"
  local ip
  local provider
  local physicalNix
  local confPath

  _checkInstance "$name"

  provider=$(_instance "$name" provider)
  _checkConfigurator "$provider"

  ip=$(_instance "$name" ip)

  echo >&2 "Initializing config..."

  # Aggregate instance config with custom configs
  mkdir -p "$NF_DIR"

  # Get instance specific config
  confPath="./$NF_DIR/module-$name.nix";
  physicalNix=$(_configure "$provider" "$ip")
  remoteSystem=$(_remoteSystem "$ip")

  cat > "$confPath" <<EOF
# DO NOT EDIT generated by 'terraflake init' (version: $(version))

{ lib, modulesPath, pkgs, ... }: with builtins; let
  input = lib.importJSON (pkgs.callPackage ./terraform-local.nix {
    terraflake-terraform-state = ../terraform.tfstate;
  });
  node = input.nodes."$name";
  nodeConf'.modulesPath = modulesPath;
  hashDir = dir:
    mapAttrs (k: v: let p = "\${dir}/\${k}"; in
      if v == "regular" then hashFile "sha1" p
      else if v == "directory" then hashDir p
      else "")
    (readDir dir);
  hash = path: let p = toString path; in
    if (readDir (dirOf p))."\${baseNameOf p}" == "directory"
    then hashString "sha1" (toJSON (hashDir p))
    else hashFile "sha1" p;
in {
  # _module.args = { inherit input node; };
  imports = [
    # Secrets module
    ({ lib, config, ... }: with lib; {
      options.terraflake.system = mkOption {
        description = "Remote system.";
        type = types.str;
      };
      options.terraflake.input = mkOption {
        description = "Data passed from provisioner.";
        type = with types; submodule { options = {
          meta = mkOption { type = attrs; };
          nodes = mkOption { type = attrs; };
          node = mkOption { type = attrs; };
        }; };
        default = { meta = {}; nodes = {}; node = {}; };
      };
      options.terraflake.filesIn = mkOption {
        description = "Attrset of paths to local files, name -> local path.";
        type = with types; attrsOf (submodule { options = {
          path = mkOption { type = path; };
          links = mkOption { type = listOf str; default = []; };
          chmod = mkOption { type = strMatching "[0-7]+"; default = "0600"; };
          user = mkOption { type = enum (attrNames config.users.users); default = "root"; };
          group = mkOption { type = enum (attrNames config.users.groups); default = "root"; };
        };});
        default = {};
      };
      options.terraflake.filesDir = mkOption {
        description = "Remote directory path to upload files to.";
        type = types.str;
        default = "/var/lib/nf-keys";
      };
      options.terraflake.filesOut = mkOption {
        description = "Attrset of paths to remote files, name -> server path.";
        type = with types; attrsOf str;
        default = {};
      };
      config.terraflake.input = input // { inherit node; };
      config.terraflake.filesOut = mapAttrs (k: v: config.terraflake.filesDir+"/"+(hash v.path)) config.terraflake.filesIn;
      config.system.activationScripts.nf-keys-permissons = concatMapStrings
        (k: let
          i = config.terraflake.filesIn."\${k}";
          o = config.terraflake.filesOut."\${k}";
        in ''
          chown -R "\${i.user}:\${i.group}" "\${o}"
          \${concatMapStringsSep "\\n" (ln: "ln -sfT '\${o}' '\${ln}'") i.links}
        '')
        (attrNames config.terraflake.filesIn);
    })

    # Hardware config gernerated by configurator: $provider
    ($physicalNix)
    ({ ... }: { terraflake.system = "$remoteSystem"; })

    # Node specific config
    # nodeConf'.configuration
  ];
  networking.hostName = "$name";
  services.openssh.enable = true;
  users.users.root.openssh.authorizedKeys.keys = [node.ssh_key];
  #system.activationScripts.nixos-cleanup = "rm -rf /old-root /boot.bak || true";
  # FIXME: this is because terraform is unfree, maybe get it with getFlake method instead?
  nixpkgs.config.allowUnfreePredicate = pkg: builtins.elem (lib.getName pkg) [
    "terraform"
  ];
}
EOF

  echo "$name" "$confPath"
}
export -f _initInstance

_buildInstance() {
  local ecode=0
  local name="$1"

  echo >&2 "Building config..."

  # shellcheck disable=SC2086
  nix build $NF_NIX_BUILD_OPTS --print-out-paths \
    "$NF_FLAKE#nixosConfigurations.$name.config.system.build.toplevel"
}
export -f _buildInstance

_pushInstance() {
  local localRealize
  local forceReboot
  local op; op="switch"
  local name
  local ip
  local provider
  local path

  while [[ -n "$1" ]]; do case "$1" in
    -l|--local) localRealize=1;;
    -b|--bundle) bundleDerivations=1;;
    -d|--dry) op="dry-activate";;
    -r|--auto-reboot) forceReboot=1;;
    -*) true;; #echo >&2 "Not a recognized push option '$1'"; return 13;;
    *)
      if [ -z "$name" ]; then name="$1"
      elif [ -z "$path" ]; then path="$1"
      fi
      ;;
  esac; shift; done

  _checkInstance "$name"
  ip=$(_instance "$name" ip)

  [[ -e "$path" ]] || { echo >&2 "Error: Not a valid config closure: $path"; return 5; }

  echo >&2 "Pushing config ($op)..."

  # XXX: move groupadd to lib/infect
  # Install Nix if not already installed
  _infect "$ip" hasNix || {
    [[ "$op" = "switch" ]] || {
      echo >&2 "Refusing to infect instance with NixOS because option --dry was given"
      exit 12
    }
    cat <(cat <<EOF
mkdir -m 0755 /nix
groupadd nixbld -g 30000 || true
for i in {1..10}; do
  useradd -c "Nix build user $i" \
    -d /var/empty -g nixbld -G nixbld \
    -M -N -r -s "$(command -v nologin)" nixbld$i \
  || true
done
EOF
    ) "$LIB_DIR"/install-nix-2.3 <(cat <<EOF
ln -fs /root/.nix-profile/bin/nix-store /usr/bin/nix-store
EOF
    ) | _remote "$ip" sh
  }

  mapfile -t caches < <(_caches "$name" | jq -r '.[]')
  mapfile -t opts <<<"$SSH_OPTS"

  # Push config closure to instance
  if [[ -n $localRealize ]]; then
    echo >&2 "Realizing NixOS config on local host"
    path=$(
      nix-store -r "$path" \
        --option substituters "${caches[0]}" \
        --option trusted-public-keys "${caches[1]}"
    ) || { echo >&2 "Error: Failed to realize derivation locally: $path"; return 11; }
    echo >&2 "Copying NixOS closure to remote host"
    NIX_SSHOPTS="${opts[*]}" \
      nix-copy-closure -s --to root@"$ip" "$path" \
      || { echo >&2 "Error: Failed to copy closure to node: $path"; return 11; }
  else
    if [[ -n $bundleDerivations ]]; then
      echo >&2 "Copying NixOS bundled config derivations to remote host"
      # shellcheck disable=SC2046
      nix-store --export $(nix-store -qR "$path") \
        | stdbuf -oL gzip \
        | _remote "$ip" sh -c "gunzip | nix-store --import"
    else
      echo >&2 "Copying NixOS config derivation to remote host"
      NIX_SSHOPTS="${opts[*]}" \
        nix-copy-closure -s --to root@"$ip" "$path" \
        || { echo >&2 "Error: Failed to copy derivation closure to node: $path"; return 14; }
    fi
    echo >&2 "Realizing NixOS config on remote host"
    path=$(_remote "$ip" sh -l <<EOF
      set -x
      nix-store -r "$path" \
        --option substituters '${caches[0]}' \
        --option trusted-public-keys '${caches[1]}'
EOF
    ) || { echo >&2 "Error: Failed to realize derivation on node: $path"; return 14; }
  fi

  # Install config and infect instance with NixOS if not already
  _infect "$ip" switch "$op" "$path" || {
    case "$?" in
      200)
        echo >&2 "Refusing to infect instance with NixOS because option --dry was given"
        exit 12
        ;;
      100)
        echo >&2 "Instance needs to reboot to finish configuration"
        if [[ -n "$forceReboot" ]]; then
          echo >&2 "Rebooting..."
          _remote "$ip" reboot </dev/null || true
        else
          echo >&2 "Refusing to reboot, use option --auto-reboot or reboot instance manually"
          exit 100
        fi
        ;;
      4)
        echo >&2 "Warning: Couldn't start all services"
        ;;
      *)
        return 8
        ;;
    esac
  }
  echo >&2 "Push successful!"
}
export -f _pushInstance

_pushAll() {
  local flags
  local name
  local path

  while [[ -n "$1" ]]; do case "$1" in
    -*) flags+=("$1");;
    *)
      if [[ -z "$name" ]]; then name="$1"
      elif [[ -z "$path" ]]; then path="$1"
      fi;;
  esac; shift; done

  _pushSecrets "$name" "${flags[@]}" \
    2> >(_ilog "$name")
  _pushInstance "$name" "$path" "${flags[@]}" \
    2> >(_ilog "$name")
}
export -f _pushAll

_init() {
  local instances

  instances=$(_checkInstances "$@")
  check "$@"
  # shellcheck disable=SC2016
  _par '_initInstance "$1" 2> >(_ilog "$1")' <<<"$instances"
}

# CLI commands

init() {
  mkdir -p "$NF_DIR"
  # Setup provisioner interfaces:
  # TODO: generalize to support multiple interfaces (eg. static JSON file, terraform cloud)
  cp --no-preserve=all "$LIB_DIR"/provisioners/terraform-local.nix "$NF_DIR/terraform-local.nix"
  _init "$@"
}

# shellcheck disable=SC2120
input() {
  local drv
  drv=$(nix-build -E "
    with builtins; let
      flake = getFlake (toString ./.);
      pkgs = import flake.inputs.nixiform.inputs.nixpkgs {
        system = currentSystem;
        config.allowUnfree = true;
      };
    in
    pkgs.callPackage ./$NF_DIR/terraform-local.nix {
      terraflake-terraform-state = ./terraform.tfstate;
    }
  ")
  nix-instantiate --eval-only --json -E "
    with builtins; fromJSON (readFile $drv)
  " | jq -rM ".${1#.} // \"\""
}
export -f input

output() {
  local name; name="$1"
  local exprs; exprs=("${@:2}")

  [[ -n "$name" ]] \
    || _usage "Missing instance name as first argument"
  [[ -n "${exprs[*]}" ]] \
    || _usage "Missing Nix expression as second argument"

  _output "$name" "{ ... }@config: with config; ${exprs[*]}" \
    2> >(_ilog "$1") \
    | jq -rM .
}
export -f output

check() {
  local instances
  local ecode; ecode=0

  instances=$(_checkInstances "$@")
  # shellcheck disable=SC2016
  _par '_checkUp "$1" 2> >(_ilog "$1")' <<<"$instances" \
    || { ecode=$?; echo >&2 "Error: Couldn't reach all instance"; return $ecode; }
}

build() {
  local path instances names flags

  while [[ -n "$1" ]]; do case "$1" in
    -*) flags+=("$1");;
    *) names+=("$1");;
  esac; shift; done

  instances=$(_checkInstances "${names[@]}")

  # shellcheck disable=SC2016
  _par '
    { path=$(_buildInstance "$@") || {
        echo >&2 "Error: Failed to build config"; exit 4
      }
    } 2> >(_ilog "$1")
    echo "$1" "$path"
  ' "${flags[@]}" <<<"$instances" \
    || { ecode=$?;echo >&2 "Error: Couldn't build all instances"; return $ecode; }
}

push() {
  local name
  local path
  local buildOutput
  local names
  local flags

  while [[ -n "$1" ]]; do case "$1" in
    -*) flags+=("$1");;
    *) names+=("$1");;
  esac; shift; done

  buildOutput=$(build "${names[@]}")
  check "${names[@]}"
  # shellcheck disable=SC2016
  _par '_pushAll "$@"' "${flags[@]}" <<<"$buildOutput"
  check "${names[@]}"
}

diff() {
  local name
  local path
  local rpath
  local buildOutput
  local names
  local ip

  while [[ -n "$1" ]]; do case "$1" in
    -*) echo >&2 "Not a recognized diff option: $1"; return 13;;
    *) names+=("$1");;
  esac; shift; done

  mapfile -t opts <<<"$SSH_OPTS"

  buildOutput=$(build "${names[@]}")
  while read -r name path; do
    ip=$(_instance "$name" ip)
    rpath=$(_remote "$ip" nix-store -q /nix/var/nix/profiles/system </dev/null)

    NIX_SSHOPTS="${opts[*]}" \
      nix-copy-closure -s --from root@"$ip" "$rpath" \

    nix-diff "$rpath" "$path" \
      2> >(_ilog "$name")
  done <<<"$buildOutput"
}

secret() {
  local flags
  local names
  local instances

  while [[ -n "$1" ]]; do case "$1" in
    -*) flags+=("$1");;
    *) names+=("$1");;
  esac; shift; done

  instances=$(_checkInstances "${names[@]}")

  # shellcheck disable=SC2016
  _par '_pushSecrets "$@" 2> >(_ilog "${@:$#}")' "${flags[@]}" <<<"$instances"
}

nodes() {
  _configs
}

ssh() {
  local name="$1"

  [[ -n "$name" ]] \
    || _usage "Missing instance name"

  $SSH_EXEC "root@$(input | jq -r ".nodes.\"$name\".ip")" "${@:2}"
}

trap 'ecode=$?;trap - EXIT
  if [[ $ecode == 0 ]]; then
    echo >&2 "Success!"
  else
    echo >&2 "Failed($ecode)!"
  fi
' EXIT
trap 'trap - TERM; kill $$' TERM

cmd=${1:-help}
declare -F | cut -d' ' -f3 | grep -q "^${cmd#_}$" \
  || _usage "No command: $cmd"

# shellcheck disable=SC2031
[[ -z $NF_DEBUG ]] || set -x

"${cmd#_}" "${@:2}"
